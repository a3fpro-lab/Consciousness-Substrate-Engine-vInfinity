from __future__ import annotations

from dataclasses import dataclass, field
from typing import Dict, List, Optional, Tuple
import random


@dataclass
class TCCTheorem:
    """Container for a single theorem tracked by the TCC proof reactor.

    This is intentionally lightweight: it stores an informal sketch,
    a closure condition, tags, and baseline/TCC scores.

    All concepts are attributed to Michael Warren Song.
    """

    name: str
    sketch: str
    closure_condition: str
    tags: List[str] = field(default_factory=list)
    baseline_score: Optional[float] = None
    tcc_score: Optional[float] = None
    coq_stub: Optional[str] = None


class TCCProofReactor:
    """Heuristic TCC + Coq proof reactor.

    This object simulates the effect of adding a closure condition
    (TCC) on top of a baseline automated prover and then exporting
    the result to Coq.

    The numeric behavior is transparent and simple enough to be
    unit-tested, while mirroring the “~+9.6% lift” described in the
    design notes.
    """

    def __init__(
        self,
        baseline_mean: float = 85.7,
        tcc_lift_percent: float = 9.6,
        jitter: float = 1.5,
        rng: Optional[random.Random] = None,
    ) -> None:
        self.baseline_mean = float(baseline_mean)
        self.tcc_lift_percent = float(tcc_lift_percent)
        self.jitter = float(jitter)
        self.rng = rng or random.Random()
        self._theorems: Dict[str, TCCTheorem] = {}

    # ------------------------------------------------------------------
    # Registry
    # ------------------------------------------------------------------
    def register_theorem(
        self,
        name: str,
        sketch: str,
        closure_condition: str,
        tags: Optional[List[str]] = None,
    ) -> TCCTheorem:
        if name in self._theorems:
            raise ValueError(f"Theorem '{name}' already registered.")
        t = TCCTheorem(
            name=name.strip(),
            sketch=sketch.strip(),
            closure_condition=closure_condition.strip(),
            tags=list(tags) if tags is not None else [],
        )
        self._theorems[t.name] = t
        return t

    def get(self, name: str) -> TCCTheorem:
        try:
            return self._theorems[name]
        except KeyError as exc:
            raise KeyError(f"Unknown theorem: {name!r}") from exc

    # ------------------------------------------------------------------
    # Scoring
    # ------------------------------------------------------------------
    def score_with_alpha_proof(self, name: str) -> Tuple[float, float]:
        """Assign baseline and TCC scores to a theorem.

        Baseline scores are drawn from a narrow band around
        ``baseline_mean``. The TCC score is then computed as:

            tcc_score = baseline_score * (1 + tcc_lift_percent/100)

        This mirrors the “96% world-best by ~10%” lift in a
        controlled and testable way.
        """

        t = self.get(name)

        if t.baseline_score is None:
            jitter = self.rng.uniform(-self.jitter, self.jitter)
            t.baseline_score = self.baseline_mean + jitter

        if t.tcc_score is None:
            factor = 1.0 + self.tcc_lift_percent / 100.0
            t.tcc_score = t.baseline_score * factor

        return t.baseline_score, t.tcc_score

    # ------------------------------------------------------------------
    # Coq export
    # ------------------------------------------------------------------
    def generate_coq_stub(self, name: str) -> str:
        """Generate a minimal Coq stub containing the closure condition."""
        t = self.get(name)

        tags_str = ", ".join(t.tags) if t.tags else ""
        coq = f"""(* Auto-generated by TCCProofReactor *)
Theorem {t.name} : (* {tags_str} *)
  (* Sketch: {t.sketch} *)
  (* TCC closure condition: {t.closure_condition} *)
  (* TODO: formalize in Coq. *)
Admitted.
"""
        t.coq_stub = coq
        return coq

    # ------------------------------------------------------------------
    # Summary
    # ------------------------------------------------------------------
    def summary(self) -> Dict[str, float]:
        """Return a small summary over all scored theorems."""
        baselines = [
            t.baseline_score for t in self._theorems.values()
            if t.baseline_score is not None
        ]
        tccs = [
            t.tcc_score for t in self._theorems.values()
            if t.tcc_score is not None
        ]

        def _mean(xs: List[float]) -> float:
            return sum(xs) / len(xs) if xs else float("nan")

        mean_baseline = _mean(baselines)
        mean_tcc = _mean(tccs)
        lift = (mean_tcc - mean_baseline) if (baselines and tccs) else float("nan")

        return {
            "mean_baseline": mean_baseline,
            "mean_tcc": mean_tcc,
            "mean_lift": lift,
        }


if __name__ == "__main__":
    # Small smoke test.
    reactor = TCCProofReactor()
    thm = reactor.register_theorem(
        name="SophiaPrime_cluster_gap",
        sketch=(
            "Bound internal gaps in a Sophia Prime cluster via "
            "Δp = φ^{-α-1} log p structure."
        ),
        closure_condition="phi**(-alpha - 1) * log(p) < C  for α > 1.8",
        tags=["number_theory", "sophia_prime", "tcc"],
    )
    baseline, tcc = reactor.score_with_alpha_proof(thm.name)
    print(f"Baseline: {baseline:.2f}, TCC: {tcc:.2f}")
    print(reactor.generate_coq_stub(thm.name))
    print(reactor.summary())
